// Simplified AI flows that work better with Next.js

interface GenerateArgumentInput {
  topic: string;
  reasoningSkill: string;
}

interface GenerateCounterArgumentInput {
  topic: string;
  formattedDebateHistory: string;
  opponentSkill: string;
  debateFormat?: string;
  userRole?: string;
  aiRole?: string;
}

interface AnalyzeArgumentInput {
  argument: string;
  topic: string;
  debateFormat?: string;
}

interface ResearchTopicInput {
  topic: string;
}

interface JudgeDebateInput {
  topic: string;
  formattedDebateHistory: string;
  debateFormat?: string;
  userRole?: string;
}

interface GeneratePoiInput {
  topic: string;
  userArgument: string;
}

// Simplified API calls using fetch directly
async function callGeminiAPI(prompt: string, systemPrompt?: string) {
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  
  if (!apiKey) {
    throw new Error('Gemini API key not found');
  }

  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: systemPrompt ? `${systemPrompt}\n\n${prompt}` : prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 2048,
        }
      })
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error(`Gemini API error: ${response.status} - ${errorData}`);
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';
  } catch (error) {
    console.error('Gemini API call failed:', error);
    // Return a fallback response instead of throwing
    return generateFallbackResponse(prompt, systemPrompt);
  }
}

// Fallback response generator for when API fails
function generateFallbackResponse(prompt: string, _systemPrompt?: string): string {
  if (prompt.includes('Generate a') && prompt.includes('argument')) {
    return `This is a simulated argument response. In a real implementation, this would be generated by the Gemini AI model based on your topic and requirements. The argument would be well-structured, persuasive, and appropriate for the specified skill level.`;
  }
  
  if (prompt.includes('counter-argument')) {
    return `This is a simulated counter-argument. The AI opponent would normally provide a structured rebuttal to your points, addressing your main arguments while presenting alternative perspectives and evidence.`;
  }
  
  if (prompt.includes('Analyze this debate argument')) {
    return `Argument Analysis:
    
Strengths:
- Clear structure and logical flow
- Relevant examples and evidence
- Persuasive language and techniques

Areas for Improvement:
- Could strengthen evidence with more specific data
- Consider addressing potential counterarguments
- Enhance conclusion with stronger call to action

Overall Assessment: This is a solid argument that demonstrates good understanding of the topic and effective debate techniques.`;
  }
  
  if (prompt.includes('Research the debate topic')) {
    return `Research Summary:

Arguments FOR:
- Strong supporting evidence exists for this position
- Multiple benefits and positive outcomes
- Backed by expert opinions and studies

Arguments AGAINST:
- Valid concerns about implementation
- Potential negative consequences to consider
- Alternative approaches may be more effective

Key Facts:
- This is a complex issue with multiple perspectives
- Recent developments have influenced the debate`;
  }
  
  if (prompt.includes('Judge this') && prompt.includes('debate')) {
    return `Debate Verdict:

After careful analysis of both sides, this was a competitive debate with strong arguments presented by both participants.

Key Observations:
- Both sides demonstrated good understanding of the topic
- Arguments were well-structured and supported
- Effective use of evidence and examples
- Good engagement with opposing viewpoints

Winner: Based on the strength of arguments and overall presentation, this debate shows balanced participation with room for improvement on both sides.

Recommendations:
- Continue practicing structured argumentation
- Focus on addressing counterarguments more directly
- Strengthen evidence with specific examples and data`;
  }
  
  if (prompt.includes('Point of Information') || prompt.includes('POI')) {
    return `"Could you clarify your position on the main benefits you mentioned, and how do you respond to the potential drawbacks?"`;
  }
  
  return `This is a simulated AI response. The actual Gemini API would provide a more detailed and contextual response based on your specific prompt and requirements.`;
}

export async function generateArgument(input: GenerateArgumentInput) {
  const prompt = `Write a natural, conversational ${input.reasoningSkill.toLowerCase()}-level debate argument for: "${input.topic}"

Write as if you're a real person speaking in a debate, not a robot. Use natural language, contractions, and conversational flow.

Structure (but don't use numbered headings):
- Start with a clear, engaging position
- Present 2-3 main supporting points naturally
- Use real examples and evidence where relevant
- Address one potential counterargument briefly
- End with a strong, memorable conclusion

Style requirements:
- Write in first person ("I believe", "In my view")
- Use natural speech patterns and contractions ("don't", "can't", "we're")
- Vary sentence length and structure
- Include rhetorical questions or direct appeals
- Sound like a real person, not an essay
- Keep it conversational but substantive
- 200-300 words maximum

Make it sound human and engaging, like someone actually speaking in a debate.`;

  const argument = await callGeminiAPI(prompt);
  return { argument };
}

export async function generateCounterArgument(input: GenerateCounterArgumentInput) {
  const systemPrompt = `You are an AI debate opponent with ${input.opponentSkill.toLowerCase()} skill level. ${input.debateFormat ? `This is a ${input.debateFormat} format debate.` : ''} ${input.aiRole ? `You are speaking as the ${input.aiRole}.` : ''}`;
  
  // Determine if we should include a proactive POI
  const shouldIncludePOI = Math.random() < 0.3; // 30% chance of proactive POI
  
  const prompt = `Topic: "${input.topic}"

Previous debate history:
${input.formattedDebateHistory}

Generate a sophisticated counter-argument that:

**Structure Requirements:**
1. **Direct Response**: Address the user's main points specifically
2. **Evidence-Based Refutation**: Use facts, examples, or logical flaws to counter
3. **Alternative Perspective**: Present your side's viewpoint with supporting evidence
4. **Strategic Argumentation**: Build toward your position systematically

**Quality Standards:**
- Skill level: ${input.opponentSkill.toLowerCase()}
- ${input.aiRole ? `Role perspective: ${input.aiRole}` : ''}
- Use specific examples, data, or case studies where relevant
- Identify and exploit logical weaknesses in opponent's argument
- Maintain professional debate decorum
- 250-350 words for thorough coverage
- Clear paragraph structure for readability

${shouldIncludePOI ? `
**POI Opportunity**: If you spot a significant contradiction, weak evidence, or unclear reasoning in the user's argument, you may include a Point of Information. Format: "POI: [sharp, focused question]" at the end.` : ''}

Provide a compelling counter-argument:`;

  const response = await callGeminiAPI(prompt, systemPrompt);
  
  // Check if the response contains a POI
  const poiMatch = response.match(/POI:\s*(.+?)(?:\n|$)/i);
  let counterArgument = response;
  let poi = null;
  
  if (poiMatch) {
    poi = poiMatch[1].trim();
    counterArgument = response.replace(/POI:\s*.+?(?:\n|$)/i, '').trim();
  }
  
  return { 
    counterArgument,
    poi: poi || undefined
  };
}

export async function analyzeArgument(input: AnalyzeArgumentInput) {
  const prompt = `Analyze this debate argument for the topic "${input.topic}":

"${input.argument}"

Provide analysis in the following format:

**Logical Fallacies:**
[List any logical fallacies found, or "None identified" if none]

**Persuasive Techniques:**
[List effective persuasive techniques used, or "None highlighted" if none]

**Strengths:**
[Key strengths of the argument]

**Weaknesses:**
[Areas for improvement]

**Counterpoints:**
[Suggest 2-3 specific counterarguments opponents might use against this argument]

**Overall Assessment:**
[Brief overall evaluation]

**Suggestions:**
[Specific suggestions for improvement]

Be constructive and educational in your feedback.`;

  const analysis = await callGeminiAPI(prompt);
  
  // Parse the response into structured format
  try {
    const lines = analysis.split('\n').filter((line: string) => line.trim());
    let logicalFallacies: string[] = [];
    let persuasiveTechniques: string[] = [];
    let strengths: string[] = [];
    let weaknesses: string[] = [];
    let overallAssessment = '';
    let suggestions: string[] = [];
    let counterpoints: string[] = [];
    
    let currentSection = '';
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.toLowerCase().includes('logical fallacies:')) {
        currentSection = 'fallacies';
        const content = trimmed.split(':')[1]?.trim();
        if (content && !content.toLowerCase().includes('none')) {
          logicalFallacies.push(content);
        }
      } else if (trimmed.toLowerCase().includes('persuasive techniques:')) {
        currentSection = 'techniques';
        const content = trimmed.split(':')[1]?.trim();
        if (content && !content.toLowerCase().includes('none')) {
          persuasiveTechniques.push(content);
        }
      } else if (trimmed.toLowerCase().includes('strengths:')) {
        currentSection = 'strengths';
        const content = trimmed.split(':')[1]?.trim();
        if (content) strengths.push(content);
      } else if (trimmed.toLowerCase().includes('weaknesses:')) {
        currentSection = 'weaknesses';
        const content = trimmed.split(':')[1]?.trim();
        if (content) weaknesses.push(content);
      } else if (trimmed.toLowerCase().includes('overall assessment:')) {
        currentSection = 'assessment';
        overallAssessment = trimmed.split(':')[1]?.trim() || '';
      } else if (trimmed.toLowerCase().includes('counterpoints:')) {
        currentSection = 'counterpoints';
        const content = trimmed.split(':')[1]?.trim();
        if (content) counterpoints.push(content);
      } else if (trimmed.toLowerCase().includes('suggestions:')) {
        currentSection = 'suggestions';
        const content = trimmed.split(':')[1]?.trim();
        if (content) suggestions.push(content);
      } else if (trimmed.startsWith('-') || trimmed.startsWith('•') || /^\d+\./.test(trimmed)) {
        const point = trimmed.replace(/^[-•\d.]\s*/, '');
        if (point) {
          switch (currentSection) {
            case 'fallacies':
              if (!point.toLowerCase().includes('none')) logicalFallacies.push(point);
              break;
            case 'techniques':
              if (!point.toLowerCase().includes('none')) persuasiveTechniques.push(point);
              break;
            case 'strengths':
              strengths.push(point);
              break;
            case 'weaknesses':
              weaknesses.push(point);
              break;
            case 'suggestions':
              suggestions.push(point);
              break;
            case 'counterpoints':
              counterpoints.push(point);
              break;
          }
        }
      } else if (currentSection === 'assessment' && trimmed) {
        overallAssessment += (overallAssessment ? ' ' : '') + trimmed;
      }
    }
    
    // Provide meaningful feedback if sections are empty
    if (logicalFallacies.length === 0) {
      logicalFallacies = ["No significant logical fallacies identified. Good logical structure!"];
    }
    
    if (persuasiveTechniques.length === 0) {
      persuasiveTechniques = ["Consider incorporating more rhetorical devices like analogies, statistics, or expert testimony"];
    }
    
    if (strengths.length === 0) {
      strengths = ["Clear communication of main points", "Relevant to the debate topic"];
    }
    
    if (weaknesses.length === 0) {
      weaknesses = ["Could benefit from stronger evidence", "Consider addressing potential counterarguments"];
    }
    
    if (!overallAssessment) {
      overallAssessment = "This argument demonstrates good understanding of the topic with room for enhancement in evidence and structure.";
    }
    
    if (suggestions.length === 0) {
      suggestions = ["Strengthen your argument with specific examples and data", "Consider the opposing perspective to make your argument more robust"];
    }
    
    if (counterpoints.length === 0) {
      counterpoints = ["Opponents might argue that your evidence is insufficient", "Critics could challenge your main assumptions", "Alternative solutions might be more effective"];
    }
    
    return {
      logicalFallacies,
      persuasiveTechniques,
      strengths,
      weaknesses,
      feedback: overallAssessment,
      suggestions,
      counterpoints
    };
  } catch (error) {
    console.error('Error parsing argument analysis:', error);
    
    // Fallback structured response
    return {
      logicalFallacies: ["No significant logical fallacies identified. Good logical structure!"],
      persuasiveTechniques: ["Consider incorporating more rhetorical devices like analogies, statistics, or expert testimony"],
      strengths: ["Clear communication of main points", "Relevant to the debate topic"],
      weaknesses: ["Could benefit from stronger evidence", "Consider addressing potential counterarguments"],
      feedback: analysis || "This argument demonstrates good understanding of the topic with room for enhancement in evidence and structure.",
      suggestions: ["Strengthen your argument with specific examples and data", "Consider the opposing perspective to make your argument more robust"],
      counterpoints: ["Opponents might question your evidence sources", "Critics could argue for alternative approaches", "Some may challenge your underlying assumptions"]
    };
  }
}

export async function researchTopic(input: ResearchTopicInput) {
  const prompt = `Conduct comprehensive research on the debate topic: "${input.topic}"

Provide detailed, high-quality content in these sections:

**ARGUMENTS FOR (Supporting the motion):**
- 3-4 strong, evidence-based arguments
- Include specific examples, statistics, or case studies where possible
- Focus on logical reasoning and real-world applications
- Each point should be 1-2 sentences with clear impact

**ARGUMENTS AGAINST (Opposing the motion):**
- 3-4 strong counter-arguments with evidence
- Address potential problems, limitations, or negative consequences
- Include alternative perspectives and competing priorities
- Each point should be substantive and well-reasoned

**KEY FACTS & EVIDENCE:**
- 2-3 crucial statistics, studies, or factual points
- Recent developments or historical context
- Expert opinions or authoritative sources
- Quantifiable data that supports analysis

Requirements:
- Use current, relevant information
- Provide balanced, objective analysis
- Include specific examples and data points
- Ensure arguments are debate-ready and substantive

Format your response clearly with these sections.`;

  const research = await callGeminiAPI(prompt);
  
  // Parse the research response or provide structured fallback
  try {
    // Try to extract structured data from the response
    const lines = research.split('\n').filter((line: string) => line.trim());
    let proPoints: string[] = [];
    let conPoints: string[] = [];
    let keyFacts: string[] = [];
    
    let currentSection = '';
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.toLowerCase().includes('for') && trimmed.toLowerCase().includes('motion')) {
        currentSection = 'pro';
      } else if (trimmed.toLowerCase().includes('against') && trimmed.toLowerCase().includes('motion')) {
        currentSection = 'con';
      } else if (trimmed.toLowerCase().includes('fact') || trimmed.toLowerCase().includes('statistic')) {
        currentSection = 'facts';
      } else if (trimmed.startsWith('-') || trimmed.startsWith('•') || /^\d+\./.test(trimmed)) {
        const point = trimmed.replace(/^[-•\d.]\s*/, '');
        if (point && currentSection === 'pro') {
          proPoints.push(point);
        } else if (point && currentSection === 'con') {
          conPoints.push(point);
        } else if (point && currentSection === 'facts') {
          keyFacts.push(point);
        }
      }
    }
    
    // Fallback to default structure if parsing fails
    if (proPoints.length === 0) {
      proPoints = [
        `Supporting evidence exists for this position on ${input.topic}`,
        `Multiple benefits and positive outcomes can be identified`,
        `Expert opinions and studies back this perspective`
      ];
    }
    
    if (conPoints.length === 0) {
      conPoints = [
        `Valid concerns exist about the implementation of ${input.topic}`,
        `Potential negative consequences should be considered`,
        `Alternative approaches may be more effective`
      ];
    }
    
    if (keyFacts.length === 0) {
      keyFacts = [
        `This topic involves complex considerations with multiple stakeholder perspectives`,
        `Recent developments have influenced the current debate landscape`
      ];
    }
    
    return {
      proPoints: proPoints.slice(0, 3),
      conPoints: conPoints.slice(0, 3),
      keyFacts: keyFacts.slice(0, 2)
    };
  } catch (_error) {
    // Fallback structured response
    return {
      proPoints: [
        `Strong supporting evidence exists for this position on ${input.topic}`,
        `Multiple benefits and positive outcomes can be identified`,
        `Expert opinions and studies support this perspective`
      ],
      conPoints: [
        `Valid concerns exist about the implementation of ${input.topic}`,
        `Potential negative consequences should be carefully considered`,
        `Alternative approaches may prove more effective`
      ],
      keyFacts: [
        `This is a complex issue with multiple stakeholder perspectives`,
        `Recent developments have significantly influenced the debate`
      ]
    };
  }
}

export async function judgeDebate(input: JudgeDebateInput) {
  const prompt = `You are an expert debate judge evaluating this ${input.debateFormat || 'standard'} debate on: "${input.topic}"

DEBATE TRANSCRIPT:
${input.formattedDebateHistory}

${input.userRole ? `User's Role: ${input.userRole}` : ''}

JUDGING CRITERIA:
Evaluate based on: Argument strength, Evidence quality, Logical consistency, Rebuttal effectiveness, Overall persuasiveness

REQUIRED OUTPUT FORMAT:

**WINNER DETERMINATION:**
Declare winner (user/ai/tie) with clear reasoning

**CLASH ANALYSIS:**
Identify 2-3 key clash points where arguments directly opposed each other:
- Clash Point: [specific topic]
- Summary: [what each side argued]
- Winner: [who won this clash and why]
- Score: [+2 to -2, positive favors user]

**PERFORMANCE ANALYSIS:**

User Strengths:
- [Specific strength with example]
- [Another strength]

User Weaknesses:
- [Specific area for improvement]
- [Another weakness]

AI Strengths:
- [AI's strong points]

AI Weaknesses:
- [AI's weak areas]

**OVERALL ASSESSMENT:**
Provide a comprehensive 3-4 sentence analysis of the debate quality, key turning points, and overall performance.

**FINAL SCORE:** [-5 to +5, where positive favors user]

**ADVICE FOR USER:**
One specific, actionable recommendation for improvement.

Be thorough, fair, and educational in your analysis.`;

  const verdict = await callGeminiAPI(prompt);
  
  // Enhanced parsing for better structure
  try {
    const lines = verdict.split('\n').filter(line => line.trim());
    let winner: 'user' | 'ai' | 'tie' = 'tie';
    let overallAssessment = '';
    let finalScore = 0;
    let userStrengths: string[] = [];
    let userWeaknesses: string[] = [];
    let aiStrengths: string[] = [];
    let aiWeaknesses: string[] = [];
    let adviceForUser = '';
    let clashes: any[] = [];
    
    let currentSection = '';
    let currentClash: any = {};
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.toLowerCase().includes('winner') && trimmed.includes(':')) {
        const winnerText = trimmed.split(':')[1]?.trim().toLowerCase();
        if (winnerText?.includes('user')) winner = 'user';
        else if (winnerText?.includes('ai')) winner = 'ai';
        else winner = 'tie';
      }
      
      if (trimmed.toLowerCase().includes('overall assessment')) {
        currentSection = 'assessment';
      } else if (trimmed.toLowerCase().includes('user strengths')) {
        currentSection = 'userStrengths';
      } else if (trimmed.toLowerCase().includes('user weaknesses')) {
        currentSection = 'userWeaknesses';
      } else if (trimmed.toLowerCase().includes('ai strengths')) {
        currentSection = 'aiStrengths';
      } else if (trimmed.toLowerCase().includes('ai weaknesses')) {
        currentSection = 'aiWeaknesses';
      } else if (trimmed.toLowerCase().includes('final score')) {
        const scoreMatch = trimmed.match(/-?\d+/);
        if (scoreMatch) finalScore = parseInt(scoreMatch[0]);
      } else if (trimmed.toLowerCase().includes('advice for user')) {
        currentSection = 'advice';
      } else if (trimmed.startsWith('-') || trimmed.startsWith('•')) {
        const point = trimmed.replace(/^[-•]\s*/, '');
        if (point) {
          switch (currentSection) {
            case 'userStrengths':
              userStrengths.push(point);
              break;
            case 'userWeaknesses':
              userWeaknesses.push(point);
              break;
            case 'aiStrengths':
              aiStrengths.push(point);
              break;
            case 'aiWeaknesses':
              aiWeaknesses.push(point);
              break;
          }
        }
      } else if (currentSection === 'assessment' && trimmed && !trimmed.includes('**')) {
        overallAssessment += (overallAssessment ? ' ' : '') + trimmed;
      } else if (currentSection === 'advice' && trimmed && !trimmed.includes('**')) {
        adviceForUser += (adviceForUser ? ' ' : '') + trimmed;
      }
    }
    
    // Provide meaningful defaults if parsing fails
    if (userStrengths.length === 0) {
      userStrengths = ["Demonstrated understanding of the topic", "Maintained consistent position"];
    }
    if (userWeaknesses.length === 0) {
      userWeaknesses = ["Could strengthen evidence with more specific examples", "Consider addressing counterarguments more directly"];
    }
    if (aiStrengths.length === 0) {
      aiStrengths = ["Structured argumentation", "Logical consistency"];
    }
    if (aiWeaknesses.length === 0) {
      aiWeaknesses = ["Could provide more varied evidence", "Sometimes repetitive in approach"];
    }
    if (!overallAssessment) {
      overallAssessment = "This was a competitive debate with both sides presenting valid arguments. The discussion showed good engagement with the topic and demonstrated understanding of key issues. There were clear moments of clash where opposing viewpoints were directly addressed. Overall, the debate maintained a professional tone and covered important aspects of the topic.";
    }
    if (!adviceForUser) {
      adviceForUser = "Focus on providing more specific evidence and examples to support your arguments, and consider anticipating and addressing potential counterarguments proactively.";
    }
    
    // Create sample clashes if none were parsed
    if (clashes.length === 0) {
      clashes = [
        {
          clashPoint: "Core argument validity",
          summary: "Fundamental disagreement on the main premise of the debate",
          winner: winner,
          winnerScore: finalScore > 0 ? 1 : finalScore < 0 ? -1 : 0,
          reasoning: winner === 'user' ? "User provided stronger foundational arguments" : winner === 'ai' ? "AI presented more compelling counter-evidence" : "Both sides presented equally valid perspectives"
        }
      ];
    }
    
    return {
      winner,
      overallAssessment,
      clashes,
      finalScore,
      userStrengths,
      userWeaknesses,
      aiStrengths,
      aiWeaknesses,
      adviceForUser
    };
  } catch (error) {
    console.error('Error parsing judge verdict:', error);
    
    // Fallback structured response
    return {
      winner: 'tie' as 'user' | 'ai' | 'tie',
      overallAssessment: "This was a well-structured debate with both participants demonstrating good understanding of the topic. The arguments presented were logical and relevant, with clear positions maintained throughout. Both sides engaged effectively with the core issues, though there were opportunities for stronger evidence and more direct clash resolution. The debate maintained a professional tone and covered the essential aspects of the topic comprehensively.",
      clashes: [
        {
          clashPoint: "Primary argument strength",
          summary: "Core disagreement on the fundamental approach to the topic",
          winner: 'tie' as 'user' | 'ai' | 'tie',
          winnerScore: 0,
          reasoning: "Both sides presented compelling arguments with valid supporting evidence"
        }
      ],
      finalScore: 0,
      userStrengths: ["Clear communication of main points", "Consistent position throughout", "Good topic understanding"],
      userWeaknesses: ["Could strengthen with more specific evidence", "Consider addressing counterarguments more directly", "Opportunity for stronger conclusion"],
      aiStrengths: ["Structured response format", "Logical argument flow", "Appropriate evidence usage"],
      aiWeaknesses: ["Could vary argumentation style", "Sometimes predictable approach", "Limited creative examples"],
      adviceForUser: "Focus on incorporating more specific, real-world examples and statistics to strengthen your arguments, and practice anticipating and preemptively addressing potential counterarguments."
    };
  }
}

export async function generatePoi(input: GeneratePoiInput) {
  const prompt = `Generate a Point of Information (POI) for this debate topic: "${input.topic}"

The user is currently arguing:
"${input.userArgument}"

Create a brief, challenging POI question that:
- Challenges a specific point in their argument
- Is relevant to the topic
- Can be answered in 15-20 seconds
- Follows POI conventions

Provide just the POI question:`;

  const poiQuestion = await callGeminiAPI(prompt);
  return { poiQuestion };
}